# Morton Filter:一种基于偏置、压缩、和耦合度更低来实现更快、空间利用率更高的布谷鸟过滤器

## 作者
Alex D. Breslow Advanced Micro Devices, Inc. AMD Research
2485 Augustine Drive Santa Clara, CA 95054
Alex.Breslow@amd.com

Nuwan S. Jayasena Advanced Micro Devices, Inc. AMD Research
2485 Augustine Drive Santa Clara, CA 95054
Nuwan.Jayasena@amd.com

## 摘要
近似性成员集合(ASMDSs)在如今计算中非常常见,使用可调整的、较低的错误率(ε)来换取可观的空间节省.较为经典的ASMDSs如Bloom Filter(布隆过滤器),仅支持查看与插入,但是并不支持删除.Cuckoo Filter(布谷鸟过滤器)是一种近期被研发出来的一类ASMDSs,增加了对删除的支持,并通过对每个元素进行更少的资源分配来达到相等的错误率(ε).
这篇论文介绍了Morton Filter(MF),这是一种新型的ASMDSs,对CFs进行了一些关键的改进.与CFs类似,MF支持查看、插入与删除,但其各自的吞吐量提高了1.3倍至2.5倍,0.9倍至15.5倍,以及1.3倍至1.6倍.MF达到这样的增长是通过(1)引入压缩格式,允许逻辑上稀疏的过滤器紧凑地存储在内存中.（2）利用简洁的嵌入式元数据来减少不必要的内存访问.（3）严格偏向于使用单一的哈希函数插入.通过这些优化,查找、插入和删除通常只需要访问过滤器的一个硬件缓存行.这些改进并没有损失空间效率,因为在相同的错误率(ε)的条件下,MF使用的空间通常与CF相当,甚至更小.

## 前言
随着时代的进步,计算机系统在内存层级上又有所新增,在今天的企业级服务器中,拥有三到四级硬件缓存、一个巨大的内存池、几个固态硬盘和一个磁盘池的情况并不少见.随着层次结构的增加,延迟和带宽通常会增加一个或多个数量级.为了避免不必要地访问较慢的介质,许多应用程序使用了近似性成员集合（ASMDSs）.ASMDS像一个哈希集合(例如:元素e是否存在于集合S当中?).然而,不同于哈希集合,ASMDSs无法给出准确的答案,而是给出基于错误率（例如:元素e在S当中的概率）,最差的情况下,错误率(ε)可能为1.ASMDS不会给出虚假的否定结果：如果ASMDS报告e不在S中,那么它肯定不在.ASMDS的一个核心优势是它的错误率ε通常与被编码的元素大小无关,所以ASMDS通常可以比它过滤请求的慢速介质在内存层次上高出一到两级.最常见的ASMDS是布隆过滤器(Bloom Filter),通过一些不同于布隆过滤器的变体来支持删除和计算一个项目的出现次数,尽管存储成本会增加（增加2倍到4倍并不罕见[10, 30]）但是布隆过滤器还是被用于数据存储系统,如谷歌的BigTable[17],分布式分析平台,如Apache Impala[41],生物信息学应用,如DNA测序期间的k-mers计数[49],各种网络应用[14]等等.布隆过滤器的缺陷之一是其最简单的版本表现出较差的参考性,而更适合缓存友好的变体通常空间效率较低[14].

因此,有许多其他的过滤器被提出来,其中两个最实用的过滤器是商数过滤器[6,59]和布谷鸟过滤器[29].商数过滤器和布谷鸟过滤器都与布隆过滤器不同,它们存储的是指纹、短哈希值,每个短哈希值通常与被过滤器编码为属于一个集合S的元素e有一对一的映射关系.布谷鸟过滤器和商数过滤器都支持删除,当过滤器达到负载系数时（即容量负载达到95%）,当期望的错误率(ε)低于1%到3%时,比同等的布隆过滤器使用的空间要少,这是大量应用的普遍情况.

在这篇论文中,我们重点关注布谷鸟过滤器（CF）,并提出了一个新的变体,即 Morton Filter（MF）.与CF一样,MF的存储被组织成一个线性的桶(Bucket)阵列,每个桶包含固定数量的槽(Slot),每个槽可以存储一个指纹(Fingerprint).指纹被映射到表中,方法是将指纹放置在两个桶中的一个,其索引由两个哈希函数（H1和H2）独立确定,这两个函数分别对键进行操作,并输出不同的桶索引.只要有一个候选桶有剩余容量,插入就会成功.当两个候选桶都满了的时候,通过布谷鸟散列[58]来解决,这种散列技术会触发一个递归的驱逐链.

尽管有这些相似之处,但MF在几个关键方面有所不同.与CF相比,MF能够在更大程度上偏重于H1的搜索.这种偏向性使得随后的指纹搜索需要较少的缓存访问,因为大多数时候,指纹是在第一个桶中找到的.对于阴查询（对从未插入表中的键的查询）,过滤器采用了溢出追踪数组（OTA）,这是一个简单的位向量,用于追踪何时不能使用H1放置指纹.通过检查OTA,大多数阴查询只需要访问一个桶,即使是在过滤器负载很高的情况下.这种偏置和追踪意味着,无论查询的类型是什么（阳性、假阳性或阴性）,通常只需要访问一个桶.当桶驻留在cache中时,大多数情况下,每个过滤器的探针只需要1次cache访问,最多2次,节省了接近50%.

除了偏置,MF还将它们的逻辑表示与它们的数据在虚拟内存中的存储方式解耦.它们在逻辑上降低了过滤器的负载,并应用了一种简单的压缩算法,用一系列追踪每个逻辑桶的负载的满度计数器来代替存储占用空间的空槽.有了满度计数器,对MF的读取和更新就会在原地发生,而不需要明确的物化.这种零压缩使得逻辑卸载过滤器(1)更好的空间效率,因为许多大部分的空桶可以被打包到一个单一的缓存块中；(2)更高的性能,因为访问直接发生在压缩的实现上,而且只发生在被占用的槽上.

对于逻辑上欠载的桶,大多数插入只需要从MF中访问单一的高速缓存行.例如,在一个有60个槽的MF块中,有59个槽被占用,对任何桶的插入都可能直接成功.然而,在一个CF中,同样的60个槽被安排成15个4槽的桶,同样的插入操作只有1/15的机会直接成功（也就是说,不需要访问额外的桶）.因此,MF能更有效地利用稀缺的缓存和内存带宽,并在比CF更重的负载下保持高的插入吞吐量（例如,对于负载系数超过0.75的过滤器,其吞吐量要高出3倍到15倍）.

此外,MF通常比CF进行更少的指纹比较,每次查询少于一次指纹比较的情况并不罕见,即使是在过滤器负载很重的情况下.相反,许多查询可以完全或部分解决,只需检查一个或两个满度计数器和OTA中的一个位.

由于这种压缩、稀疏和偏置,MF的吞吐量、空间使用和灵活性都得到了改善.由于较少的比较、缓存访问次数,MF提高了查找、删除和插入的吞吐量,与现有CF相比,分别提高了2.5倍、1.6倍和15.5倍.同样,这些特性允许使用更短的指纹,因为假阳性与指纹比较的数量是完全相关的.因此,满度计数器和OTA的空间开销在很大程度上可以被隐藏,每项的空间通常可以比具有相同ε的CF减少大约0.5到1.0比特.

我们的贡献如下.
1. 我们介绍了Morton滤波器的设计和经验评估，这是一种新型的ASMDS，它使用压缩、稀疏和偏置来提高吞吐量，而不牺牲空间效率或灵活性。在过滤器的读取和更新过程中，MF通过访问更少的高速缓存行来提高性能，超过CF。
2. 我们通过将过滤器的对数表示与存储方式解耦，大大改善了基于指纹的ASMDS在高负载下插入吞吐量崩溃问题（对于CF来说大于100倍）。
3. 我们提出了一种快速的算法，用于计算满度计数器的减少，这是高性能的关键，并且可以应用于其他情况。
4.  我们提出了一种散列机制，它可以减少TLB缺失、行缓冲区缺失和页面故障，并且不要求总桶数是2的幂。
5. 我们打算向更更广泛的研究社区发布一个C++ MF实现，我们已经在基于Linux的AMD和Intel X86服务器处理器上进行了测试。

## Cuckoo Filters

在这一小节里，我们将会来描述MF的祖先:CF

### 基本设计

CF是存储指纹的哈希集合，其中每个指纹都是通过使用哈希函数HF计算的，该函数将代表该集合中某一项目的键作为输入，并将其映射为固定长度的哈希。过滤器的结构是一个二维矩阵，其中行对应于被称为桶的固定宽度的关联单元，行内的单元格对应于槽，每个槽能够存储一个指纹。之前的工作通常使用4槽的桶[29]。

为了将每个键的指纹映射到过滤器上，并最大程度上解决哈希碰撞问题，Fan等人通过将键的指纹存储在两个候选桶中的一个。密钥的两个候选桶是使用两个哈希函数H1和H2独立计算的。H1把键作为输入，产生一个候选桶的索引，H2对同一个键进行计算，产生另一个候选桶的索引[29]。

### 插入

在插入时，只要两个候选桶的8个槽中至少有一个是空的，操作就完成了，将指纹存储在一个空槽中。如果没有空槽，则采用布谷鸟算法[58]。布谷鸟算法在两个桶中挑选一个指纹，驱逐该指纹并将新的指纹存储在新腾出的槽中。然后，被驱逐的指纹被使用其备用哈希函数重新散列到其备用桶中。为了简单地使用桶的索引和指纹作为输入来计算备用哈希函数，他们去掉了一个新的散列函数H′，它把指纹和它当前的桶作为输入并返回另一个候选桶。因此，如果目前在H1(key)给出的第一个候选桶中发现了指纹，H′就会产生H2(key)给出的另一个候选桶，反之亦然。只要候补候选者有空闲的位置，被驱逐的键就会被放置，操作就会成功。如果没有这样的空位，最初被驱逐的指纹将被取代，操作继续进行，直到找到一个空槽。

图1中显示了两个插入的例子。第一个例子是键Kx，它成功了，因为H2将其指纹x映射到有空位的Bucket 0。第二个例子是针对键Ky的，它最初未能在其他候选桶（6和4）中找到一个空位，因此使用布谷鸟算法将从桶6中的1011开始，以桶2中的1101结束的指纹链移到桶1中的一个空位。请注意，在实践中，为了避免在每个步骤中存储被替换的指纹，一系列的替换可能会以相反的顺序发生。

![Figure 1](https://github.com/Max-Cheng/morton_filter-CN/master/img/1.png)

图1：通过存储各自的指纹x和y，将两个不同的键Kx和Ky插入到过滤器中。 空槽显示为灰色。Kx的插入只涉及到访问它的两个候选桶（4和0），因为0有一个空位，但Ky的候选桶（6和4）都是满的，所以一系列的指纹被移到他们的备用候选桶中，以便在桶6中为y提供一个空位。更新后的过滤器如图2所示。



![Figure 2](https://github.com/Max-Cheng/morton_filter-CN/master/img/2.png)

图2：在图1中成功插入各自的指纹x和y后，对两个不同的键Kx和Ky进行查找。对于Ky，步骤4和5可以选择跳过，因为y是在第一个候选桶中找到的。



### 查找

在查找过程中，该算法计算H1和H2以计算其候选桶，并计算HF以确定其指纹。如果指纹出现在两个候选桶的8个槽中的任何一个，那么查询就会返回**可能存在集合中**，否则就**不在集合中**。**可能存在集合中**的确定性受制于假阳率ε，该错误率可通过为每个指纹分配一个适当的比特长度来调整。值得注意的是，假阳性的实际发生率将在0（所有的查询都是针对插入过滤器的项）到ε（没有查询的项被插入过滤器）之间取值，这取决于查询是否是针对集合的成员。

图2是在图1的过滤器中插入键Kx和Ky之后。即使Ky触发了一系列的迁移，但由于它只允许在其两个候选桶中的一个插入，所以只需要搜索桶6和桶4。对于任何其他被查询的键也是如此：最多需要遍历两个桶。



### 假阳率和空间使用率的建模

在这一节中，我们提出了计算布谷鸟过滤器错误率的公式，它的每项空间使用量，并展示了如何利用本研究的见解来实现设计一个MF（见第3节对MF的高级描述）。

| **表1**：符号词汇表 |                                     |
| ------------------- | --------------------------------- |
| ε                   | 假阳率                             |
| S                   | 每个桶的槽数                        |
| b                   | 每个负数查询所搜索的桶 α - 负载系数    |
| f                   | 指纹长度（比特）                     |
| I                   | 过滤器中每个项的比特                  |

表1提供了一个符号的词汇表。

每一个CF都有一个假阳率ε，它报告了假阳率的预期比例与总的可能包含真阴性的查询（即对真阳性没有假阳性的风险）。为了理解ε是如何被计算出来的，我们首先介绍几个术语。$S$是指每个桶的槽位，$b$是指每次负面查询需要搜索的桶的预期数量，$α$是指负载系数，$f$是指每个指纹的位数。当把一个$f$位的指纹与存储在桶中的指纹进行比较时，如果所有的指纹值都是同样的可能性，那么发生别名（即与另一个键插入的指纹虚假匹配）的可能性是$1/2^f$
有$2f$个潜在值，其中只有一个可以别名。为了计算别名的净概率，Fan等人[29]先前的工作观察到每个桶有S个槽，b固定为2（总是搜索两个桶），因此假阳率$ε = 1 − (1 − 1/2^f )^{bS}$所以目标ε的必要f大致为$f=log2（bS/ε）$，对于他们的参数S=4和b=2而言，$f=3+log2（1/ε）$

然而，这个模型忽略了α的影响，也就是说，如果一个人很小心，清楚地标记了空槽（通过保留$1/2f$来编码空槽），那么在执行查找时，空槽就不可能别名。标记空槽的公示会稍微有所改变，$ε=1-(1-1/(2f-1))^{αbS}$，这将$f$的计算公式改变为$f = log2(αbS/ε)$(1) 对于f的典型值（即f>6）。对于欠载的过滤器，事实证明，额外的$α$项很重要，因为$0≤α≤1$，其对数小于或等于零。例如，半负载过滤器$(α=0.5)$意味着分子中的$α$在目标$ε$的情况下使f的所需长度减少了$log2（α=0.5）=1$比特，此外，这种影响在每项节省的比特中被放大（如公式2所示）。有了额外的$α$和固定的$ε$，$α=0.5$将使每项所需的比特数减少至$log2(0.5)/0.5=2$比特,超越了Fan等人的悲观模型。